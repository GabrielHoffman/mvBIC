
---
title: "Power analysis for mvBIC"
subtitle: ''
author: "Developed by [Gabriel Hoffman](http://gabrielhoffman.github.io/)"
date: "Run on `r Sys.time()`"
documentclass: article
output: 
  html_document:
  toc: true
  smart: false
vignette: >
  %\VignetteIndexEntry{Gene set enrichment from genomic intervals}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
  %\usepackage[utf8]{inputenc}
---

<!--- 
# devtools::install_github('GabrielHoffman/pinnacle', auth_token='f74018151cf7c902b57aa023b2737190e9bc0400')

R CMD INSTALL -l $R_LIBS_USER ../

source ~/.bash_profile
cd /hpc/users/hoffmg01/build2/mvBIC/vignette
module load R/3.6.0 pandoc openssl boost git
git pull origin dev
alias R='R --quiet --no-save --no-restore-data'
R

# Sys.setenv(GITHUB_PAT = "f74018151cf7c902b57aa023b2737190e9bc0400")

devtools::reload("/Users/gabrielhoffman/workspace/repos/mvBIC")



rmarkdown::render("sims.Rmd", output_dir='./', intermediates_dir='./')



# run analysis
# cd /Users/gabrielhoffman/workspace/repos/mvBIC/vignettes
# cd /hpc/users/hoffmg01/build2/mvBIC/vignettes

# rm -fr sims_*
 --->

```{r load.packages, echo=FALSE, message=FALSE, results='hide'}
suppressPackageStartupMessages(library(knitr))
suppressPackageStartupMessages(library(data.table))
suppressPackageStartupMessages(library(mvBIC))
suppressPackageStartupMessages(library(variancePartition))

options(xtable.type="html")

setDTthreads(3, restore_after_fork=FALSE)

knitr::opts_chunk$set(
  echo=FALSE,
  warning=FALSE,
  message=FALSE,
  error = FALSE,
  tidy = FALSE,
  cache = TRUE,
  cache.lazy = FALSE,  dev = c("png", "pdf"), 
  fig.width=7, fig.height=7)

options(markdown.HTML.stylesheet = 'css/custom.css')
```

do GEUVADIS, SEQC, GTEX, CMCv2 + simulations
Compare to summing standard BIC

Simulation, show probability of selection true model increases with number of features 
# compare to sum of BIC


devtools::reload("/Users/gabrielhoffman/workspace/repos/mvBIC")

```{r basic}
n = 100
p = 200
m_active = 1
X = matrix(rnorm(n*p), n, p)
colnames(X) = paste0('X_', 1:p)
beta = matrix(rnorm(m_active*p, 10), m_active,p)
Noise = matrix(rnorm(n*p), n, p)
Y = X[,1:m_active] %*% beta + Noise
trueSet = sort(colnames(X)[1:m_active])

bestModel = mvForwardStepwise( t(Y), ~1, X, colnames(X))

bestModelNaive = mvForwardStepwise( t(Y), ~1, X, colnames(X), useMVBIC=FALSE)
```


```{r sim.scale}
library(poolr)
library(mvBIC)
library(ggplot2)
library(mvtnorm)
library(data.table)
library(CVTuningCov)

set.seed(1)

n_reps = 20   
n = 100 # number of samples
# p = 10 # number of genes
# m_active = 2 # number of variables affecting phenotype
m_total = 10 # total number of variables

 # summary(lm(Y~X[,1]))
# lapply(coef(summary(lm(Y~X[,1]))), function(fit) fit[2,4])

m_active_array = c(1, 2, 3)
signalFraction = .8#seq(.4, .8, by=.1)
ngenes_array = c(round(seq(10, 100, length.out=5), 0), 200, 500)
rho_array = seq(0, .98, length.out=5)

resRecovery = lapply(1:n_reps, function(k){

  # set.seed(k)

  resRecovery = lapply(m_active_array, function(m_active){
    resRecovery = lapply(signalFraction, function(sigFrac){

      # simulate variables
      X = matrix(rnorm(m_total*n), n, m_total)
      colnames(X) = paste0('X_', 1:m_total)
      trueSet = sort(colnames(X)[1:m_active])

      resRecovery = lapply(ngenes_array, function(p){

        # simulate coefficient for each gene
        beta = matrix(rnorm(p*m_active, 10), m_active,p)
        beta[sample.int(length(beta), length(beta)*.5)] = 0 

        resRecovery = lapply( rho_array, function(rho){

            message("\rk = ", k, '  p = ', p, ' rho = ', rho, ' sigFrac =  ', sigFrac,  ' m_active = ', m_active, '        ')  

            # changes correlation structure of noise. Need to change magnitude
            Sigma = matrix(rho, p,p)
            diag(Sigma) = 1
            # Sigma = AR1(p, rho)
            Noise = rmvnorm(n, sig=Sigma)

            eta = X[,1:m_active,drop=FALSE] %*% beta 
            fctr = mean(apply(eta,1, var)) * (1-sigFrac)/sigFrac
            # fctr = 10

            Y = eta + Noise*fctr
            # cor(eta[1,], eta[1,] + Noise[1,]*fctr)^2

            # try 3 logDet methods
            methods = c( "Touloumis_unequal", "pseudodet")  #"Strimmer" "Touloumis_equal"
            res = sapply( methods, function(method){
              # message(method)
              # if( k==1 & p==10 & rho==0 & signalFraction==.99) browser()
              bestModel = mvForwardStepwise( t(Y), ~1, X, colnames(X), verbose=FALSE, logDetMethod=method, deltaCutoff=5)
              # test of selected set is the true set
              vars = subset(bestModel$trace, isAdded == "yes")$variable
              vars = as.character(vars)
              identical( sort(vars), trueSet)
              })
            names(res) = methods
          
            # fit naive model
            bestModelNaive = mvForwardStepwise( t(Y), ~1, X, colnames(X), useMVBIC=FALSE, verbose=FALSE, deltaCutoff=5)

            # test of selected set is the true set
            vars = subset(bestModelNaive$trace, isAdded == "yes")$variable
            vars = as.character(vars)
            result_naive = identical( sort(vars), trueSet)

            data.frame( method = c(paste("mvBIC", methods, sep=' - '), 'naive'),
                        recovery = c(res, result_naive),
                        rho = rho,
                        k = k,
                        p = p,
                        sigFrac = sigFrac,
                        m_active = m_active)
          })
          do.call(rbind, resRecovery)
        })
        do.call(rbind, resRecovery)
      })
    do.call(rbind, resRecovery)
    })
    do.call(rbind, resRecovery)
})
resRecovery = do.call(rbind, resRecovery)
resRecovery = data.table(resRecovery)
```

```{r plot.sims, cache=FALSE, fig.width=15}
# summarize 
df = resRecovery[,data.frame(recoveryRate = sum(recovery)/length(recovery)),by=c('rho', 'p', 'sigFrac', 'm_active','method')]
df$sd = with(df, sqrt(recoveryRate*(1-recoveryRate)/n_reps))
df$up = with(df, recoveryRate + sd)
df$down = with(df, recoveryRate - sd)

cols = c("red", "orange", "dodgerblue", "green", "black")

# pdf("~/www/mvBIC.pdf", width=12)
ggplot(df, aes(rho, recoveryRate, color=method, fill=method)) + geom_ribbon(aes(ymin=down, ymax=up), alpha=.3, linetype=0) + geom_line() + geom_point() + scale_color_manual("Method", values = cols ) + scale_fill_manual("Method", values = cols ) + xlab(bquote(Correlation~(rho))) + ylab("Power to recover true model") + theme_bw() + theme(aspect.ratio=1) + ylim(0, 1) + facet_wrap(~m_active+p, ncol=length(ngenes_array)  )
# dev.off()
```

# Using dynamic lambda


<!---

# naive
mvBIC_fit( t(Y), ~ X_1 + X, X, useMVBIC=FALSE)
mvBIC_fit( t(Y), ~ 1, X, useMVBIC=FALSE)

method = "Touloumis_unequal"
# method="pseu"
res1 = mvBIC_fit( t(scale(Y)), ~ X_1, X, logDetMethod=method, lambda=lambda)
res1@params
res2 = mvBIC_fit( t(scale(Y)), ~ 1, X, logDetMethod=method, lambda=lambda)
res2@params
res1-res2




residMatrix1 = t(residuals(lm(scale(Y) ~ X_1, data=as.data.frame(X))))
residMatrix2 = t(residuals(lm(scale(Y) ~ 1, data=as.data.frame(X))))


mvBIC:::mvBIC_from_residuals( residMatrix1, 3, lambda=0.317 )
mvBIC:::mvBIC_from_residuals( residMatrix2, 2, lambda=0.317 )

rlogDet( residMatrix1, method="Touloumis_unequal" )
rlogDet( residMatrix2, method="Touloumis_unequal" )

rlogDet( residMatrix1, method="Touloumis_equal" )
rlogDet( residMatrix2, method="Touloumis_equal" )

rlogDet( residMatrix1, method="Str" )
rlogDet( residMatrix2, method="Str" )

rlogDet( residMatrix1, method="pseudo" )
rlogDet( residMatrix2, method="pseudo" )

d1 = svd(residMatrix1)$d^2 
d2 = svd(residMatrix2)$d^2 
# plot(d1, d2, log="xy")

a = sum(log(d1))
b = sum(log(d2))

v = sapply( 1:100, function(k){
  a = sum(log(d1[1:k]))
  b = sum(log(d2[1:k]))
  a-b
})
plot(v)


d1[1:3]
adjusted_eigen_values(residMatrix1, method="p")[1:3]


d1 = d1[1:99]
d2 = d2[1:99]

sum(log(d1))*100 - sum(log(d2))*100




res = shrinkcovmat.equal_lambda( residMatrix2 )
# lambda = res$lambda_hat
lambda = 0.3707678
ev_return = (1-lambda) * ev + lambda * res$nu_hat





library(denoiseR)

sig = estim_sigma(residMatrix1, method = "MAD")

res1 = optishrink( residMatrix1, sigma = sig, method = "ASYMPT", k=ncol(residMatrix1)-1)
sum(log(res1$singval^2))

res2 = optishrink( residMatrix2, sigma = sig, method = "ASYMPT", k=ncol(residMatrix1)-1)
sum(log(res2$singval^2))

plot(svd(residMatrix1)$d, svd(residMatrix2)$d)
plot(res1$singval[1:19], res2$singval[1:19])
abline(0,1, col="red")

# Compute delta BIC directly


res = optishrink( residMatrix1 - residMatrix2, method="ASYMPT")

d = svd(residMatrix1 - residMatrix2)$d
sum(2*log(d[1]))

d1 = svd(residMatrix1)$d^2
d2 = svd(residMatrix2)$d^2
adjusted_eigen_values( residMatrix1, method = "p")[1:3]


sum(log(d1)) - sum(log(d2)) 


C = tcrossprod(residMatrix2)
eigen(C)$values[1:4]

svd(residMatrix2)$d[1:4]^2






res = shrinkcovmat.identity(residMatrix1)
str(res)








bestModel = mvForwardStepwise( t(Y), ~1, X, colnames(X)[1:10])

method = "rlogDet"

a = mvBIC_fit(t(Y), ~ X_3 , X, verbose=TRUE, logDetMethod = method)
b = mvBIC_fit(t(Y), ~ X_10 + X_5 + X_9, X, verbose=TRUE, logDetMethod = method)
as.numeric(a - b)    


a = mvBIC_fit(t(svd(Y)$u), ~ X_3 , X, verbose=TRUE, logDetMethod = method)
b = mvBIC_fit(t(svd(Y)$u), ~ X_10 + X_5 + X_9, X, verbose=TRUE, logDetMethod = method)
as.numeric(a - b)    


a = mvBIC_fit(t(svd(Y)$u), ~ X_3 , X, verbose=TRUE, useMVBIC=FALSE, logDetMethod = method)
b = mvBIC_fit(t(svd(Y)$u), ~ X_10 + X_5 + X_9, X, verbose=TRUE, useMVBIC=FALSE, logDetMethod = method)
as.numeric(a - b)    




library(maotai)

n = 5
p = 10
Y = matrix(rnorm(n*p), n, p)

evalues = svd(Y)$d^2
sum(log(evalues[evalues > 1e-10]))

C = crossprod(Y)
evalues = eigen(C)$values
sum(log(evalues[evalues > 1e-10]))

log(pdeterminant(C))





n = 1000
p = 50
A = cor(matrix(rnorm(p*n),ncol=n))   # (n x n) matrix
k = as.double(Matrix::rankMatrix(A)) # rank of A


evalues = eigen(A)$values
pdet = sum(log(evalues[evalues > 1e-5]))

# smallest eigen-value
# (1-sqrt(n/p))^2
# evalues[p-1]

# x = p:n
# plot(x, (1-sqrt(n/x))^2)

# iterative computation
ntry = 11
del.vec = exp(-(1:ntry))
det.vec = rep(0,ntry)
for (i in 1:ntry){
  del = del.vec[i]
  # det.vec[i] = det(A+del*diag(n))/(del^(n-k))
  det.vec[i] = determinant(A+diag(del,n))$modulus[1] - (n-k)*log(del)
}

# visualize the results
opar <- par(no.readonly=TRUE)
plot(log(del.vec), det.vec, main=paste("true rank is ",k," out of ",n,sep=""),"b", xlab="iterations")
abline(h=pdet,col="red",lwd=1.2)
par(opar)


min(eigen(A+diag(del,n))$values)



finite sample size estimator for log det


n = 200

res = lapply( seq(20, 5*n, length.out=10), function(p){

  logDet = sapply(1:10, function(i){
    A = cor(matrix(rnorm(p*n),ncol=n))  
    determinant(A)$modulus[1]
    })
  data.frame(logDet, p)
})
res = do.call(rbind, res)

ggplot(res, aes(p, logDet)) + geom_point() + theme_bw()


library(corpcor)
library(HiDimDA)

n = 500
p = 30
X = matrix(rnorm(p*n),ncol=n)
A = cor(X)   # (n x n) matrix

res = ShrnkSigE( df=p-1, n, min(n,p-1), Sigma=A, Trgt = "Idntty")
res$Intst

evalues = eigen(A)$values
sum(log(evalues[evalues > 1e-10]))

sum(log(res$D))

sum(log(eigen(res)$values))

plot(eigen(A)$values, eigen(res)$values)

C = cov2cor(A)
ev = eigen(C)$values

get_lambda = function(ev, n, p){
  a = sum(ev^2) + sum(ev)^2
  b = n * sum(ev^2) + (p-n+1)/p * sum(ev)^2
  a / b
}
lambda = get_lambda(ev, n, p)

sum(log(ev*(1-lambda) + lambda))

sum(log(ev))


estimate.lambda(X)
 c = cor.shrink(X)
 attr(c, "lambda")



library(clusterGeneration)
library(mvtnorm)
library(corpcor)
library(HiDimDA)
library(TAS)
library(ShrinkCovMat)
library(ggplot2)
library(reshape2)
library(Rfast)



estLogDet = function( X, method, scale=TRUE){
  
  p = nrow(X)
  n = ncol(X)

  if( scale ){
      # A = cor(X)   # (n x n) matrix
    X_std = scale(X)/sqrt(p-1)
  }else{
    X_std = X
  }

  rnk = min(n, p-1)
  # ev = eigen(A)$values
  ev = svd(X_std)$d[1:rnk]^2

  if( method == "Strimmer"){
    lambda = estimate.lambda(X, verbose=FALSE)
    ev_shrink = (ev*(1-lambda) + lambda)
    ev_hat = c(ev_shrink, rep(lambda, n-length(ev_shrink)))
  }else if( method == "gcShrink"){
    suppressWarnings({
    res = gcShrink(t(X), var=1, cor=1, plot=FALSE)
    })
    lambda = res$optimalpha
    ev_gc = ev*(1-lambda) + lambda
    ev_hat = c(ev_gc, rep(lambda, n-length(ev_gc)))
  }else if( method == "ShrinkCovMat"){
  
    res = shrinkcovmat.identity(t(X), centered=FALSE)
    lambda_hat = res$lambdahat

    ev_shrink2 = (ev*(1-lambda_hat) + lambda_hat)
    ev_hat = c(ev_shrink2, rep(lambda_hat, n-length(ev_shrink2)))
  }else if( method == "ShrnkSigE"){

    res = ShrnkSigE( df=p-1, n, min(n,p-1), Sigma=cor(X), Trgt = "Idntty")
    lambda = ifelse("Intst" %in% names(res), res$Intst, 0)

    ev_gc = ev*(1-lambda) + lambda
    ev_hat = c(ev_gc, rep(lambda, n-length(ev_gc)))
  }else if(method == "rlogDet"){
    ev_hat = rlogDet(X)
  }else if(method == "population"){
    ev_hat = ev
  }else{
    stop("Method not found")
  }

  ev_hat
}


# 
useFast = FALSE
# n = 1000
p_array = c(seq(50, 100, by=20), seq(120,300, by=30))
# n_array = c(seq(4, 1500, by=100), seq(2000, 10000, by=500))
n_array = c(seq(4, 1000, by=100))


res = lapply( n_array, function(n){
  cat("\rn = ", n, '      ')
  res = lapply( p_array, function(p){

    if( useFast ){
      # construct data from eigen values
      # evTrue = eigen(Sigma)$values
      evTrue = sort(runif(n, 1, 1), decreasing=TRUE)
      Q <- clusterGeneration:::genOrthogonal(n) 
      # Sigma <- Q %*% diag(evTrue) %*% t(Q)
      # evTrue[1:3]
      # 
      # R = t(Q %*% (t(Q) * sqrt(pmax(evTrue, 0))))
      R = crossprod(sweep(Q, 1, evTrue,FUN="*"), Q)

      X = matrnorm(p, n) %*% R
      # crossprod(X)/p

    }else{
      # Generate correlation directly
      Sigma = cov2cor(genPositiveDefMat(n, ratioLambda=100, lambdaLow=30)$Sigma)
      evTrue = eigen(Sigma)$values
      X = mvtnorm::rmvnorm(p, sig=Sigma)
    }
   
    # logDet
    res = data.frame( n = n,
                      p = p,
                      True          = sum(log(evTrue)),
                      Population    = sum(log(estLogDet(X, "population"))),
                      # Strimmer      = sum(log(estLogDet(X, "Strimmer"))),
                      Strimmer       = rlogDet(X, "Strimmer"),
                      Touloumis       = rlogDet(X, "Touloumis"))
                      # gcShrink      = sum(log(estLogDet(X, "gcShrink"))),
                      # ShrinkCovMat  = sum(log(estLogDet(X, "ShrinkCovMat"))))
                      # ShrnkSigE     = sum(log(estLogDet(X, "ShrnkSigE"))))
    res

  })
  res = do.call(rbind, res)
})
res = do.call(rbind, res)

res2 = res
idx = colnames(res2) %in% c('n', 'p', 'True')
res2 = cbind(n=res2$n, p=res2$p, (res2[,!idx] - res$True))
df = melt(res2, id.vars=c('n', 'p'))

pdf("~/www/mvBIC.pdf")
ggplot(subset(df, variable!="Population"), aes(n, value, color=variable)) + geom_point() + theme_bw() + theme(aspect.ratio=1) + ylab("Percent error") + facet_wrap(~p)
dev.off()




fig1 = ggplot(res, aes(True, Strimmer)) + geom_point( ) + theme_bw() + theme(aspect.ratio=1) + ylab("Percent error")
fig2 = ggplot(res, aes(True, Touloumis)) + geom_point( ) + theme_bw() + theme(aspect.ratio=1) + ylab("Percent error")

plot_grid(fig1, fig2)












# plot(evTrue, ylim= range(c(evTrue, ev, ev_shrink, ev_gc)))
# points(ev,col="red")
# points(ev_shrink,col="blue")
# points(ev_gc,col="green")

# logDet
sum(log(evTrue))
sum(log(ev[1:(p-1)]))
sum(log(ev_shrink))
sum(log(ev_gc))
rlogDet( X )


sum(log(ev_shrink2))





target = diag(1,n)

obj = optimize( function(alpha) logML(t(X), target, alpha), interval=c(1e-6, 1-1e-6), tol=1e-6, maximum=TRUE)





phase2_formula <- "~Dx.Tissue + (1 | Individual_ID) + RIN2 + (1 | Institution) + ageOfDeath + RIN + PMI + EV.1 + (1 | Reported_Gender) + EV.2 + EV.3 + EV.4"
phase3 <- mvBIC::mvForwardStepwise(exprObj = subset_CQN[1:10,],
                         baseFormula = phase2_formula, 
                         data = COVARIATES,
                         variables = array(c("scale(IntragenicRate)", "scale(IntronicRate)","IntergenicRate)","scale(rRNARate)", "scale(TotalReads)", "scale(GenesDetected)", "scale(MappedReads)")))


y = subset_CQN[1,]
phase2_formula <- "y~Dx.Tissue + (1 | Individual_ID) + RIN2 + (1 | Institution) + ageOfDeath + RIN + PMI + EV.1 + (1 | Reported_Gender) + EV.2 + EV.3 + EV.4 + scale(TotalReads)"

fit = lme4::lmer(phase2_formula, COVARIATES)


--->













